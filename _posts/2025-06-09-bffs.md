---
layout: post
image: assets/images/system-design/capa-resiliencia.png
author: matheus
featured: false
published: true
categories: [ system-design, engineering, cloud ]
title: System Design - Backend for Frontends
---

# Definindo Backend for Frontends

Os **BFFs**, ou **Backends for Frontends**, são **padrões arquiteturais que criam backends especializados para cada tipo de frontend**. Em vez de utilizarmos um único backend responsável por atender requisições de todos os clientes e interfaces, concluímos que **as requisições vindas de um cliente mobile possuem requisitos de negócio, segurança e escalabilidade diferentes dos de clientes web ou APIs públicas**. Nesse contexto, **criamos aplicações segregadas para intermediar e tratar de forma especializada cada tipo de consumo do serviço**.

Ao contrário de [API Gateways](/api-gateway/) e de [balanceadores de carga e proxies reversos](/load-balancing/), que são componentes de infraestrutura responsáveis por desacoplar os backends e fornecer interfaces unificadas para vários microsserviços, **os BFFs são aplicações completas, com suas próprias características de capacidade, escalabilidade e segurança**, e **podem atuar como backends desses componentes de infraestrutura**.


<br>

# Responsabilidades Arquiteturais

Os **BFFs** propõem a criação de um **serviço intermediário** responsável por **simplificar a integração do frontend** com os microsserviços necessários para executar as operações solicitadas pelo cliente. Para essa função, diversas responsabilidades podem ser acopladas ao BFF, tais como **autenticação**, **autorização**, **acesso a cache**, **requisições a múltiplos serviços**, **composição de payloads**, **gestão de filtros**, **adaptação de contratos** (renomear campos, formatar dados), **ordenar listas** e **acionar fallbacks** quando necessário.

Ao delegar essa série de tarefas e complexidades — antes exclusivas do cliente — aos BFFs, **ganhamos em clareza de código**, **responsabilidade clara de cada funcionalidade**, **performance otimizada** e **isolamento de canais** de frontend, como **IoT**, **mobile**, **páginas web** e **dispositivos domésticos inteligentes**.

A seguir, serão apresentados os principais pontos arquiteturais aprimorados pela implementação do padrão BFF.


## API Composition Pattern

O **API Composition Pattern** refere-se à prática de **consolidar diversas requisições a serviços backend distintos em um único ponto de entrada**. Para simplificar esse fluxo para o frontend, podemos **incorporar essa lógica no BFF**, de modo que o canal de consumo realize apenas **uma única requisição** ao Backend for Frontend. Internamente, o BFF executa os demais requests, **consolida e formata os payloads**, e finalmente **retorna a resposta ao cliente no formato esperado**.

Dessa forma, **minimizamos a latência de rede** entre o cliente e múltiplos servidores, **simplificamos o código do frontend** e **ganhamos flexibilidade para aplicar transformações**, como **filtragem de campos sensíveis**, **enriquecimento de dados** ou **ordenação específica**, sem expor ao usuário a complexidade do ecossistema de microsserviços.


## Segregação de Canais

Na implementação de **BFFs**, assumimos que **cada canal de usuário** — desktop, web, mobile (iOS, Android) ou dispositivos domésticos e de IoT — **pode ter requisitos distintos** quanto ao **formato de dados**, **volume de transações**, **comportamento** e **regras de cache**. A **segregação de canais** em **BFFs** distintos implica **criar instâncias e versões independentes** para cada perfil de cliente, de modo que **cada BFF conheça a jornada e os fluxos específicos** do seu público-alvo.

Dessa forma, **evitamos condicionais complexas** no código e **focamos nas necessidades específicas** de cada canal. Por exemplo:

- **Canal Web**: pode servir conteúdo por meio de **SSR (Server-Side Rendering)**, gerenciar sessão em um **cache centralizado** (por exemplo, Memcached) e realizar **autenticação e autorização** via **tokens JWT**, além de oferecer **mais funcionalidades** comparado a outros modos de acesso.  
- **Canal Mobile**: costuma exigir **respostas enxutas**, **compressão de dados** mais intensa e **funcionalidades de sincronização** offline.  
- **Canal IoT**: precisa suportar **conexões intermitentes**, usar protocolos como **[MQTT e WebSockets](/mensageria-eventos-streaming/)** e adotar uma **gestão criteriosa de segurança e privacidade** dos dados trafegados.  

Todos esses cenários se beneficiam de **interfaces de comunicação dedicadas**, implementadas como seus respectivos **Backends for Frontends**.


## Segregação de Microfrontends

Em projetos que adotam a **fragmentação da camada de visualização em microfrontends**, cada módulo independente é mantido por um time com responsabilidades próprias. Nessa abordagem, faz sentido criar **BFFs coesos e exclusivos para cada microfrontend**, garantindo que cada equipe tenha **autonomia e responsabilidade** sobre sua funcionalidade específica. O BFF de cada módulo atua como um **mini-orquestrador independente**, encarregado de gerenciar e formatar os dados necessários — desde o carregamento de widgets e dashboards até o processamento de notificações e operações de CRUD — sem expor as complexidades dos microsserviços “core” para o restante da aplicação.

Essa estratégia, indicada principalmente para **projetos de grande porte** que reforçam a [Lei de Conway](/monolitos-microservicos/), fortalece o princípio de **equipes “end-to-end”**, em que cada time domina toda a jornada da feature — do microfrontend ao seu backend dedicado — assegurando **alinhamento total entre UI e APIs**.

## Versionamento de Interfaces

A **aplicação correta e desacoplada de BFFs** pode nos ajudar a testar **novas versões de produtos** e até **descontinuar versões legadas**. Por meio de **feature toggles e deployments inteligentes** (/deployment-strategies/), podemos ter **várias versões do BFF** em produção e **alternar** qual delas está **ativa** ou **inativa**. Quando lançamos **uma nova versão de uma feature, produto ou frontend**, podemos criar um **BFF dedicado a essa versão**, facilitando **experimentações controladas** com públicos específicos e evitando **toggles adicionais** ou **condicionais** complexas.

<br>

### Referências

[Backend For Frontend: Uma estratégia sob medida para a entrega de microsserviços](https://medium.com/jeitosanar/backend-for-frontend-uma-estrat%C3%A9gia-sob-demanda-para-a-entrega-de-microsservi%C3%A7os-2f12d4cb9e3f)

[Arquitetura BFF — Back-end for Front-end](https://medium.com/digitalproductsdev/arquitetura-bff-back-end-for-front-end-13e2cbfbcda2)

[Pattern: Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)

[Backend for Frontend Pattern](https://www.geeksforgeeks.org/backend-for-frontend-pattern/)