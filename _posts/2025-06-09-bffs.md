---
layout: post
image: assets/images/system-design/capa-resiliencia.png
author: matheus
featured: false
published: true
categories: [ system-design, engineering, cloud ]
title: System Design - Backend for Frontends
---

# Definindo Backend for Frontends 

Os BFF's, ou Backend for Frontends **são padrões arquiteturais que buscam criar backends especializados para cada tipo de frontend de uso comum do cliente**. Ao invés de utilizarmos um único backend responsável por atender requisições de todos os tipos de clientes e interfaces, podemos chegar a conclusão de que as **requisições vindas de um cliente mobile possuem características de negócio, segurança e escalabilidade diferentes de clientes web ou API's abertas**, nesse contexto **criamos aplicações segregadas para intermediar e tratar de forma especializada** cada um dos meios de consumo do serviço. 

Ao contrário de [API Gateways](/api-gateway/) e [Balanceadores de Carga e Proxies Reversos](/load-balancing/) que são componentes de infraestrutura intermediários responsáveis por desacoplar os backends e fornecer interfaces únicas de contato com diversos microserviços, **os BFF's são de fato aplicações, que por sua vez possuem seu próprio [Capacity, caraterísticas de Escalabilidade](/performance-capacidade-escalabilidade/), Segurança** e inclusive **podem estar sendo servidos como backends desses componentes**. 

<br>

# Responsabilidades Arquiteturais

Os BFF's propõe a criação de um serviço intermediário responsável por simplificar a integração do frontend com os microserviços que o mesmo precisa se comunicar para realizar as operações iniciadas pelo cliente. Para essa função, várias responsabilidades podem ser acopladas na construção desse tipo de servico, desde a autenticação, autorização, acesso a caches, realizar requests para multiplos serviços, composição de payloads, gestão de filtros, adaptação de contratos, renomeando campos, formatando dados, ordenando listas e acionando fallbacks se necessário. No geral, ao delegar essa série de tarefas e complexidades que antes pertenceriam ao cliente para os BFF's, conseguimos evoluir em clareza de código, responsabilidade, performance e responsabilidade das funcionalidades dos canais de frontend como interfaces IOT's, Mobile, páginas web e aparelhos domésticos inteligentes. Aqui vamos abordar os principais pontos arquiteturais que conseguimos melhorar nos nossos sistemas implementando os patterns de BFF's.  

## API Composition Pattern 

O API Composition Pattern refere-se à prática de consolidar, num único ponto de entrada, diversas requisições a serviços backend distintos. Para simplificar essa série de tarefas para o frontend, podemos acoplar essa lógica nos BFF's, de fato que o canal de consumo realize apenas um único request para o Backend for Frontend, e o mesmo de forma interna consiga realizar os demais requests, consolidação e formatação dos payloads e finalmente retorná-lo ao canal da forma como o mesmo espera.  Dessa forma podemos minimizar a latência de rede do cliente para diversos servidores, simplificar o código cliente e o ganho de flexibilidade para aplicar transformações, como filtragem de campos sensíveis, enriquecimento de dados ou ordenação específica, sem expor diretamente a complexidade do ecossistema de microsserviços para a camada de visualização da UI. 

## Segregação de Canais

Na implementação de BFF's, assumimos que cada canal de usuário ou frontend, seja ele desktop, web, mobile, iOS, Android ou dispositivos domésticos ou de IoT potem ter requisitos diferentes a respeito do formato de dados, volume de transações, comportamentos e regras de cache diferentes para cada tipo de cenário.  A segregação desses canais em BFF's diferentes implica em criar instâncias e versões diferentes para cada tipo ou perfil desses clientes, de modo que cada BFF's conheça a jornada e os fluxos do público alvo do canal. 

Dessa forma podemos evitar uma série de condicionais de tratativas diferentes que podem variar de acordo com a origem de solicitação e focar nas necessidades especificas de cada uma delas. Como por exemplo, um canal web pode servir seu conteúdo por meio de SSR (Server-Side Rendering), gerenciar a sessão através de um memcached centralizado ou realizar suas tarefas de autenticação e autorização por meio de Tokens JWT, além de possuir uma maior gama de features liberadas comparado aos outros modos de acesso, e todas essas features são implementadas diretamente no BFF do canal. Um canal Mobile pode necessitar de  priorização de respostas mais enxutas e com compressão de dados mais intensa, além ter features de sincronização. Um canal de IOT precisa oferecer suporte pra conexões intermitentes, necessitar de protocolos como [MQTT e Websockets](/mensageria-eventos-streaming/) uma gestão mais criteriosa da segurança e privacidade dos dados trafegados. 

Todos esses modelos podem fazer uso de interfaces de comunicação e simplificação dedicadas e especializadas, sendo essas seus respectivos Backend for Frontends. 

## Segregação de Microfrontends

Em projetos que segreguem sua camada de visualização em microfrontends, fragmentando assim a aplicação em modulos independentes com times com responsabilidades independentes, podemos ter BFF's coesos e exclusivos para cada um desses modulos, para que os times responsáveis consigam ter responsabilidade e autonomia para sua funcionalidade em específico. Cada Microfrontend pode ter seu grupo de rotas, funcionalidades e requisitos específicos, onde tudo isso pode ser encapsulados dentro de um Backend for Frontend do modulo que é capaz de atuar como um mini-orquestrador independente responsável por gerenciar os dados de responsabilidade da págica, como fornecer os dados formatados para carregamento dos Widgets e Dashboardds, gerenciar as notificações, gerenciar as operações de CRUD e etc. 

Esse tipo de abordagem, além de ser extremamente granular e só fazer sentido em projetos de grande porte e onde se reforça a [Lei de Conway](/monolitos-microservicos/), mas reforça  o princípio de equipes “end-to-end”, onde um time responsável pela feature controla toda a jornada, tanto o microfrontend quanto seu backend dedicado, garantindo alinhamento total entre UI e APIs, atuando como usuários do restante dos microserviços e componentes "core" do sistema. 


## Versionamento de Interfaces

A aplicação correta e desacoplada de BFF's podem nos ajudar a testar novas versões de produtos e até descontinuar versões mais legadas. Através de [feature toggles e deployments inteligentes](/deployment-strategies/), podemos manter versões diferentes do BFF no ar e chavear qual delas estará ativada ou desativada. Uma nova versão de uma feature, produto ou frontend pode acarretar em uma versão do BFF dedicada pra essa versão, podendo facilitar a experimentação controlada com certos públicos da experiência completa, no caso canal e seu respectivo backend, sem a necessidade toggles adicionais ou condicionais. 

<br>

### Referências

[Backend For Frontend: Uma estratégia sob medida para a entrega de microsserviços](https://medium.com/jeitosanar/backend-for-frontend-uma-estrat%C3%A9gia-sob-demanda-para-a-entrega-de-microsservi%C3%A7os-2f12d4cb9e3f)

[Arquitetura BFF — Back-end for Front-end](https://medium.com/digitalproductsdev/arquitetura-bff-back-end-for-front-end-13e2cbfbcda2)

[Pattern: Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)

[Backend for Frontend Pattern](https://www.geeksforgeeks.org/backend-for-frontend-pattern/)