---
layout: post
title: Serverless Framework âš¡ï¸ â€” Criando (ou migrando) uma REST API com Express.js
  e AWS Lambda.
canonical_url: https://medium.com/@fidelissauro/serverless-framework-%EF%B8%8F-criando-ou-migrando-uma-rest-api-com-express-js-e-aws-lambda-51834740dcdb?source=rss-fc2fda5e9bc2------2
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7NgiewIZzLd180ihdNqBpA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/8KfCR12oeUM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Christopher Burns</a> onÂ <a href="https://unsplash.com/search/photos/builder?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>TL;DR; Esse post Ã© o resultado de alguns labs que tenho feito para suprir algumas demandas de alguns clientes meus, afim de encontrar formas simples e baratas de fazer deploy de aplicaÃ§Ãµes colocando escala, disponibilidade e custo na balanÃ§a. Para isso iremos migrar uma aplicaÃ§Ã£o construÃ­da para rodar em servidores dedicados, ou containers usando <strong>Express.JS</strong> para o <strong>AWS Lambda</strong>, utilizando o <strong>Serverless Framework</strong> com ajuda do plugin <strong>serverless-http, </strong>aproveitando o mÃ¡ximo do negÃ³cio e forÃ§a de trabalho jÃ¡ existente.</p><p>Essa abordagem Ã© um uso do Serverless muito diferente da tradicional, quando pensamos em APIâ€™s REST, pensamos em uma funÃ§Ã£o lambda responsÃ¡vel por atender especificamente um endpoint, pra um mÃ©todoÂ HTTP.</p><p>Essa abordagem, vamos criar um proxy resource, no <strong>API Gateway</strong> da <strong>AWS</strong>, e fazer com que apenas uma funÃ§Ã£o lambda seja responsÃ¡vel por atender todas as chamadas da API, independente do recurso ou mÃ©todo solicitado.</p><blockquote>COMO ASSIM???</blockquote><p>Na verdade, vamos aproveitar as rotas de uma aplicaÃ§Ã£o <strong>Express</strong> jÃ¡ existente, vamos pensar nesse post como uma passo a passo pra migraÃ§Ã£o de uma aplicaÃ§Ã£o jÃ¡ fundada para o <strong>Serverless</strong>, aproveitando tudo o que jÃ¡ foi anteriormente construÃ­do, toda a arquitetura, os controllers, libraries, configuraÃ§Ãµes eÂ etc.</p><p>As vantagens dessa abordagem</p><ul><li>Custo</li><li>Escala</li><li>Performance</li><li>Deploy</li><li>Validar a ideia de umÂ MVP</li><li>Time toÂ Market</li><li>Onboarding do desenvolvedor</li><li>Capacidade de mudar instantaneamente para servidores ou containers.</li></ul><p>PorÃ©m, nÃ£o Ã© fÃ¡cil resumir de uma maneira generalista tudo que uma aplicaÃ§Ã£o precisa pra rodar. Portanto, vou levantar alguns dos maiores pontos de dor da maioria das aplicaÃ§Ãµes, e de como conseguimos suprir as demandas dos mesmos com os recursos presentes dentro do <strong>Serverless Framework</strong>, focando Ã© claro, no saudosoÂ Express.</p><ul><li>Rotas</li><li>Deploy</li><li>ReplicaÃ§Ã£o</li><li>VariÃ¡veis deÂ Ambiente</li></ul><h4>Instalando o Serverless CLI</h4><p>Podemos instalar o CLI do Serverless via modo global viaÂ npm.</p><pre>sudo npm install -g serverless</pre><h4>Instalando as dependÃªncias doÂ exemplo.</h4><p>Vamos instalar algumas libs normais, que a maioria das aplicaÃ§Ãµes em Express utilizam, e tambÃ©m o <strong>serverless-offline</strong>, para conseguirmos simular nosso ambiente localmente.</p><pre>npm install --save body-parser express helmet cors consign<br>npm install --save-dev serverless-offline</pre><p>AtÃ© ai temos dependÃªncias normais de uma aplicaÃ§Ã£o Express. Para fazer ele se entender com o proxy do api gateway e responder em conjunto a uma funÃ§Ã£o lambda, precisamos instalar a uma biblioteca chamada serverless-http</p><pre>npm install --save serverless-http</pre><h4>Estrutura de diretÃ³rios</h4><p>Nossa estrutura Ã© bem simples. Na verdade, pra esse exemplo sÃ³ iremos precisar de dois arquivos, o app.js que irÃ¡ conterÂ as</p><pre>.<br>â”œâ”€â”€ app.js (arquivo de configuraÃ§Ã£o do servidor)<br>â”œâ”€â”€ controllers (pastinha onde vamos armazenar nossos controllers)<br>â”‚   â””â”€â”€ pets.js (exemplo de controller)<br>â”œâ”€â”€ handler.js (handler da funÃ§Ã£o lambda)<br>â”œâ”€â”€ package-lock.json<br>â”œâ”€â”€ package.json<br>â””â”€â”€ serverless.yml (arquivo de especificaÃ§Ãµes do serverless)</pre><pre>1 directory, 6 files</pre><h4>app.js</h4><p>Esse arquivo irÃ¡ conter todas as especificaÃ§Ãµes do nosso servidor Express. Assim como fazemos nas aplicaÃ§Ãµes normais. Iremos adicionar o mÃ³dulo para habilitar CORS, o helmet para aplicar uma camada de seguranÃ§a nas requisiÃ§Ãµes recebidas, o Body Parser para popularmos o body das nossas requests e o consign, fazendo o require de todos as rotas dentro da pasta controllersÂ .</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cacd7346e82e6daa9cfce6ce99f1720a/href">https://medium.com/media/cacd7346e82e6daa9cfce6ce99f1720a/href</a></iframe><h4>controllers/pets.js</h4><p>Esse Ã© a representaÃ§Ã£o de um controller de uma aplicaÃ§Ã£o qualquer com alguns mocks de respostas. Vamos simular um crud completo.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/17b23d7f2888f87aaf4134982dcd4322/href">https://medium.com/media/17b23d7f2888f87aaf4134982dcd4322/href</a></iframe><h4>handler.js</h4><p>Esse arquivo serÃ¡ o responsÃ¡vel por exportar o event handler do lambda. Basicamente serÃ¡ a funÃ§Ã£o que serÃ¡ executada assim que o lambda forÂ chamado.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1d86a02f083e861f7a5bcff95c1d03bc/href">https://medium.com/media/1d86a02f083e861f7a5bcff95c1d03bc/href</a></iframe><h4>serverless.yml</h4><p>O arquivo serverless.yml Ã© responsÃ¡vel por definir as especificaÃ§Ãµes das funÃ§Ãµes lambdas, como configuraÃ§Ãµes, providers, limites, triggers, recursos do Cloud Formation a seremÂ criados.</p><p>Diferente da maioria dos exemplos da utilizaÃ§Ã£o do Framework, vamos definir um path do API Gateway como um proxy a partir da raiz da API/Â , dando um pass through de todos os resources, de todos os mÃ©todos. Iremos tratar isso dentro da aplicaÃ§Ã£o. Basicamente estamosÂ dizendo:</p><blockquote>â€œHey, API Gateway, todos os recursos, todo o payload, todos os querystrings de qualquer mÃ©todo que chegar ai em vocÃª a partir da raiz, manda pra pra nossa lambda aqui. NÃ£o pensa muitoÂ nÃ£o.â€</blockquote><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/28196ddc8822f8c5f4f5802f20434598/href">https://medium.com/media/28196ddc8822f8c5f4f5802f20434598/href</a></iframe><h4>Testando a AplicaÃ§Ã£o Local</h4><p>Dentro do nosso arquivo YAML, especificamos o plugin serverless-offlineÂ . Esse Ã© um plugin muito bacana e nos fornece um set interessantes de ferramentas para simular vÃ¡rias triggers da AWS localmente.</p><pre>serverless offline start --skipCacheInvalidation</pre><p>O plugin deverÃ¡ simular um API Gateway, junto com as eventuais demais triggers e invocar as funÃ§Ãµes lambda correspondentes. Normalmente dentro da portaÂ 3000.</p><pre>Serverless: Starting Offline: v1/us-east-1.</pre><pre>Serverless: Routes for app:<br>Serverless: ANY /<br>Serverless: ANY /{proxy*}</pre><pre>Serverless: Offline listening on <a href="http://localhost:3000"><strong>http://localhost:3000</strong></a></pre><p>Agora vamos executar os testes nos endpoints utilizando oÂ curl</p><pre>curl -X GET <a href="http://localhost:3000/pets">http://localhost:3000/pets</a><br>curl -X POST <a href="http://localhost:3000/pets">http://localhost:3000/pets</a><br>curl -X PUT <a href="http://localhost:3000/pets">http://localhost:3000/pets</a>/1<br>curl -X DELETE <a href="http://localhost:3000/pets">http://localhost:3000/pets</a>/1</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*rZ-_lsuf0Crhl2Pp2_tGzA.png" /></figure><h4>Deploy</h4><p>Vamos executar o mesmo teste que fizemos localmente em produÃ§Ã£o, mas antes vamos rodar o deploy da aplicaÃ§Ã£o.</p><pre>serverless deploy -v</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BrWl8No397daHD_9nwMh8A.png" /></figure><p>Agora vamos realizar os requests da mesma forma que realizamos localmente, porÃ©m com o novo path dasÂ API.</p><pre>curl -X GET <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a><br>curl -X POST <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a><br>curl -X PUT <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a>/1<br>curl -X DELETE <a href="https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets">https://6url6g4tdd.execute-api.us-east-1.amazonaws.com/v1/pets</a>/1</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*kqEyNj5xWER0LY4nJP7n5Q.png" /></figure><h4>VariÃ¡veis deÂ Ambiente</h4><p>VariÃ¡veis de ambiente jÃ¡ sÃ£o comuns quando se tratamos de AWS Lambda, porÃ©m existem algumas limitaÃ§Ãµes. Quando precisamos replicar um ambiente, ou simular o ambiente de produÃ§Ã£o localmente, precisamos alterar muita coisa. E quando armazenamos senhas, secrets, API Keys nas variÃ¡veis de ambiente, acho uma alternativa muito legal utilizar o recurso de variÃ¡veis de ambiente do Lambda. Para isso, vamos utilizar uma abordagem que jÃ¡ Ã© comum dentro do ecossistema do Express, o mÃ³dulo configÂ .</p><p>O modulo config Ã© uma alternativa muito legal pra quem possui vÃ¡rios stages de desenvolvimento. Por default, ele sempre vai procurar arquivos JSON dentro de um diretÃ³rio chamado configÂ . Ele lÃª a variÃ¡vel NODE_ENV e procura o arquivo JSON como o nome correspondente a variÃ¡vel. Caso nÃ£o encontre, ele sempre lÃª o arquivo default.jsonÂ .</p><pre>npm install --save config </pre><p>Agora vamos criar o diretÃ³rio config/ com dois arquivos JSON de configuraÃ§Ã£o, um para desenvolvimento, e outro para produÃ§Ã£o.</p><pre>mkdir config<br>touch config/{default.json,dev.json}</pre><p>Dessa forma, vamos levar colocar as configuraÃ§Ãµes de produÃ§Ã£o dentro do arquivo default.json e os de desenvolvimento dentro do dev.jsonÂ .</p><p><strong>dev.json</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/85b43c6ce857734f4b7a31c657afe809/href">https://medium.com/media/85b43c6ce857734f4b7a31c657afe809/href</a></iframe><p><strong>default.json</strong></p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/13e5573cbe96913bc09cf3ce8515ee66/href">https://medium.com/media/13e5573cbe96913bc09cf3ce8515ee66/href</a></iframe><h4>controllers/version.js</h4><p>Agora, vamos criar um controller chamado version.js e adicionar o seguinte endpoint. Ele vai pegar algumas informaÃ§Ãµes dentro do mÃ³dulo configÂ , que por sua vez vai ser o conteÃºdo dos arquivos JSON encontrados na nossa pasta de configuraÃ§Ã£o.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ceabacd2de1b0704658b6cef08ebf963/href">https://medium.com/media/ceabacd2de1b0704658b6cef08ebf963/href</a></iframe><p>Dessa forma, nossa estrutura deverÃ¡ ficar parecida comÂ essa:</p><pre>.<br>â”œâ”€â”€ app.js<br>â”œâ”€â”€ config<br>â”‚   â”œâ”€â”€ default.json<br>â”‚   â””â”€â”€ dev.json<br>â”œâ”€â”€ controllers<br>â”‚   â”œâ”€â”€ pets.js<br>â”‚   â””â”€â”€ version.js<br>â”œâ”€â”€ handler.js<br>â”œâ”€â”€ package-lock.json<br>â”œâ”€â”€ package.json<br>â””â”€â”€ serverless.yml</pre><p>Agora vamosÂ testar:</p><p>Executando o serverless offline</p><pre>serverless offline start --skipCacheInvalidation</pre><p>Vamos testar oÂ request</p><pre>curl -X GET <a href="http://localhost:3000/version">http://localhost:3000/version</a></pre><pre>HTTP/1.1 200 OKcontent-type: application/json; charset=utf-8<br>access-control-allow-origin: *<br>x-dns-prefetch-control: off<br>x-frame-options: SAMEORIGIN<br>strict-transport-security: max-age=15552000; includeSubDomains<br>x-download-options: noopen<br>x-content-type-options: nosniff<br>x-xss-protection: 1; mode=block<br>content-length: 38<br>etag: W/&quot;26-eY7T1hNSk9rMb1We4Jgd6trR6jM&quot;<br>vary: origin<br>cache-control: no-cache<br>accept-ranges: bytes<br>Date: Tue, 03 Jul 2018 23:13:32 GMT<br>Connection: keep-alive</pre><pre><strong>{&quot;version&quot;:&quot;1.0.0&quot;,&quot;env&quot;:&quot;Production&quot;}</strong></pre><p>Agora vamos testar de novo, alterando a variÃ¡vel NODE_ENV do nossoÂ runtime.</p><pre>export <strong>NODE_ENV=dev</strong> &amp;&amp; serverless offline start<br> --skipCacheInvalidation</pre><p>Agora vamos testar novamente:</p><pre>curl -X GET <a href="http://localhost:3000/version">http://localhost:3000/version</a> -i</pre><pre>HTTP/1.1 200 OK<br>content-type: application/json; charset=utf-8<br>access-control-allow-origin: *<br>x-dns-prefetch-control: off<br>x-frame-options: SAMEORIGIN<br>strict-transport-security: max-age=15552000; includeSubDomains<br>x-download-options: noopen<br>x-content-type-options: nosniff<br>x-xss-protection: 1; mode=block<br>content-length: 39etag: W/&quot;27-TepRPuPN8rvWIUkb8umQpS4sfUo&quot;<br>vary: origin<br>cache-control: no-cache<br>accept-ranges: bytes<br>Date: Tue, 03 Jul 2018 23:20:07 GMT<br>Connection: keep-alive</pre><pre><strong>{&quot;version&quot;:&quot;1.0.0&quot;,&quot;env&quot;:&quot;Development&quot;}</strong></pre><p>Podemos editar isso no nosso arquivo package.json</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ef004f2cb2a522f88bfe819f6dbdff24/href">https://medium.com/media/ef004f2cb2a522f88bfe819f6dbdff24/href</a></iframe><p>Assim podemos iniciar nosso ambiente de desenvolvimento de forma mais intuitiva.</p><pre>npm run dev</pre><p>Para remover, usamos a mesmaÂ forma:</p><pre>serverless remove </pre><p><strong>Fontes:</strong></p><ul><li><a href="https://dev.to/adnanrahic/a-crash-course-on-serverless-apis-with-express-and-mongodb-193k">https://dev.to/adnanrahic/a-crash-course-on-serverless-apis-with-express-and-mongodb-193k</a></li><li><a href="https://serverless.com/blog/serverless-express-rest-api/">https://serverless.com/blog/serverless-express-rest-api/</a></li></ul><p>Espero ter ajudado!Â ğŸ˜ƒ</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=51834740dcdb" width="1" height="1" alt="">
